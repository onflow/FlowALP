#!/usr/bin/env bash
set -euo pipefail

# update-test-coverage-doc.sh
#
# Runs the Cadence test suite with coverage, parses the output, and updates
# the auto-generated sections of cadence/tests/TEST_COVERAGE.md.
#
# Usage:
#   ./scripts/update-test-coverage-doc.sh            # run tests and update doc
#   ./scripts/update-test-coverage-doc.sh --from-file output.txt  # parse existing output

ROOT_DIR="$(cd "$(dirname "$0")/.." && pwd)"
DOC_FILE="$ROOT_DIR/cadence/tests/TEST_COVERAGE.md"
TEST_DIR="$ROOT_DIR/cadence/tests"
OUTPUT_FILE=""

# ---------------------------------------------------------------------------
# Parse arguments
# ---------------------------------------------------------------------------
while [[ $# -gt 0 ]]; do
  case "$1" in
    --from-file)
      OUTPUT_FILE="$2"
      shift 2
      ;;
    *)
      echo "Unknown option: $1" >&2
      exit 1
      ;;
  esac
done

# ---------------------------------------------------------------------------
# Run tests (or read prior output)
# ---------------------------------------------------------------------------
if [[ -n "$OUTPUT_FILE" ]]; then
  echo "Reading test output from $OUTPUT_FILE"
  TEST_OUTPUT="$(cat "$OUTPUT_FILE")"
else
  echo "Running tests with coverage..."
  TEST_OUTPUT="$(flow test --cover --covercode="contracts" \
    "$TEST_DIR"/*_test.cdc 2>&1)" || true
fi

# ---------------------------------------------------------------------------
# Parse results
# ---------------------------------------------------------------------------
TODAY="$(date -u +%Y-%m-%d)"

# Coverage percentage — look for "Coverage: XX.X% of statements"
COVERAGE="$(echo "$TEST_OUTPUT" | grep -oP 'Coverage:\s+\K[0-9]+(\.[0-9]+)?%' | head -1)" || true
if [[ -z "$COVERAGE" ]]; then
  COVERAGE="N/A"
fi

# Count test files
TOTAL_FILES="$(find "$TEST_DIR" -maxdepth 1 -name '*_test.cdc' | wc -l)"

# Individual test results — lines like "- PASS: funcName" or "- FAIL: funcName"
PASS_COUNT="$(echo "$TEST_OUTPUT" | grep -cP '^\s*-\s+PASS:' || true)"
FAIL_COUNT="$(echo "$TEST_OUTPUT" | grep -cP '^\s*-\s+FAIL:' || true)"
TOTAL_TESTS=$((PASS_COUNT + FAIL_COUNT))

if [[ "$FAIL_COUNT" -eq 0 && "$TOTAL_TESTS" -gt 0 ]]; then
  STATUS="All tests passing"
elif [[ "$TOTAL_TESTS" -eq 0 ]]; then
  STATUS="No test results parsed"
else
  STATUS="$FAIL_COUNT failing"
fi

# ---------------------------------------------------------------------------
# Build per-file results table
# ---------------------------------------------------------------------------
# Parse "Test results: <path>" blocks followed by PASS/FAIL lines.
FILE_TABLE=""
CURRENT_FILE=""
FILE_PASS=0
FILE_FAIL=0

flush_file() {
  if [[ -n "$CURRENT_FILE" ]]; then
    local ftotal=$((FILE_PASS + FILE_FAIL))
    local fstatus="PASS"
    if [[ "$FILE_FAIL" -gt 0 ]]; then
      fstatus="FAIL"
    fi
    FILE_TABLE+="| ${CURRENT_FILE} | ${ftotal} | ${FILE_PASS} | ${FILE_FAIL} | ${fstatus} |"$'\n'
  fi
}

while IFS= read -r line; do
  if echo "$line" | grep -qP '^Test results:'; then
    flush_file
    # Extract just the filename
    CURRENT_FILE="$(echo "$line" | grep -oP '[^/]+_test\.cdc' || echo "$line")"
    FILE_PASS=0
    FILE_FAIL=0
  elif echo "$line" | grep -qP '^\s*-\s+PASS:'; then
    FILE_PASS=$((FILE_PASS + 1))
  elif echo "$line" | grep -qP '^\s*-\s+FAIL:'; then
    FILE_FAIL=$((FILE_FAIL + 1))
  fi
done <<< "$TEST_OUTPUT"
flush_file

# ---------------------------------------------------------------------------
# Build the replacement block
# ---------------------------------------------------------------------------
STATS_BLOCK="<!-- AUTO-GENERATED-STATS-START -->
<!-- Generated by scripts/update-test-coverage-doc.sh — do not edit manually -->

| Metric | Value |
|--------|-------|
| **Last Updated** | ${TODAY} |
| **Coverage** | ${COVERAGE} |
| **Test Files** | ${TOTAL_FILES} |
| **Total Tests** | ${TOTAL_TESTS} |
| **Passed** | ${PASS_COUNT} |
| **Failed** | ${FAIL_COUNT} |
| **Status** | ${STATUS} |

<!-- AUTO-GENERATED-STATS-END -->"

RESULTS_BLOCK="<!-- AUTO-GENERATED-RESULTS-START -->
<!-- Generated by scripts/update-test-coverage-doc.sh — do not edit manually -->

### Latest Test Results by File

| File | Tests | Passed | Failed | Status |
|------|-------|--------|--------|--------|
${FILE_TABLE}
<!-- AUTO-GENERATED-RESULTS-END -->"

# ---------------------------------------------------------------------------
# Update the markdown file
# ---------------------------------------------------------------------------
if [[ ! -f "$DOC_FILE" ]]; then
  echo "Error: $DOC_FILE not found" >&2
  exit 1
fi

# Replace content between markers using awk
update_section() {
  local start_marker="$1"
  local end_marker="$2"
  local new_content="$3"
  local file="$4"

  awk -v start="$start_marker" -v end="$end_marker" -v content="$new_content" '
    $0 ~ start { print content; skip=1; next }
    $0 ~ end   { skip=0; next }
    !skip       { print }
  ' "$file"
}

# Apply stats section
TEMP_FILE="$(mktemp)"
update_section "AUTO-GENERATED-STATS-START" "AUTO-GENERATED-STATS-END" \
  "$STATS_BLOCK" "$DOC_FILE" > "$TEMP_FILE"

# Apply results section
update_section "AUTO-GENERATED-RESULTS-START" "AUTO-GENERATED-RESULTS-END" \
  "$RESULTS_BLOCK" "$TEMP_FILE" > "$DOC_FILE"

rm -f "$TEMP_FILE"

echo ""
echo "Updated $DOC_FILE"
echo "  Coverage:   $COVERAGE"
echo "  Tests:      $TOTAL_TESTS ($PASS_COUNT passed, $FAIL_COUNT failed)"
echo "  Test files: $TOTAL_FILES"
echo "  Status:     $STATUS"
